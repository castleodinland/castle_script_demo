#include <iostream>
#include "fmt/format.h"
#include "fmt/core.h"

#include <vector>
#include <string>
#include <fstream>
#include <ctime>
#include <chrono>
#include <iomanip>
#include <boost/program_options.hpp>
#include <boost/regex.hpp>
#include <boost/filesystem.hpp>

#include "IniParser.h"

// Macro to define the platform-specific path separator
#ifdef _WIN32
#define PATH_SEPARATOR "\\"
#else
#define PATH_SEPARATOR "/"
#endif

namespace po = boost::program_options;
namespace fs = boost::filesystem;

std::string ver = "v0.2.1"; // Incremented version for the fix
std::string date;
std::string ini_config_file = "makefile.ini";
std::string scan_dir = "";

std::string project_name = "";
std::string make_folder = "";
std::string objs_folder = "";
std::string pre_build_script = "";
std::string config_tool_path = "";
std::string config_tool_path_cmd = "";

std::vector<std::string> exclude_src_list;
std::vector<std::string> compile_option_list;

std::vector<std::string> recursive_req;
std::vector<std::string> recursive_search_all;

std::vector<std::vector<std::string>> src_main_list;
std::vector<std::vector<std::string>> inc_full_path_list;
 
std::string libs_search_long_str;
std::string link_option_long_str;
std::string config_src_long_str;

std::string getCurrentTimestampString() {
    auto now = std::chrono::system_clock::now();
    auto currentTime = std::chrono::system_clock::to_time_t(now);

    // Use localtime_r on Linux for thread safety, localtime on Windows
#ifdef _WIN32
    std::tm localTime = *std::localtime(&currentTime);
#else
    std::tm localTime;
    localtime_r(&currentTime, &localTime);
#endif

    std::stringstream ss;
    ss << std::put_time(&localTime, "%Y-%m-%d %H:%M:%S");
    return ss.str();
}


std::string to_absolute(const std::string& path_str) {
    fs::path p(path_str);
    
    if (p.is_absolute()) {
        return path_str;
    }

    // Use canonical to get a normalized absolute path
    try {
        fs::path abs_p = fs::canonical(p);
        return abs_p.string();
    } catch (const fs::filesystem_error& e) {
        // Fallback to absolute if canonical fails (e.g., path doesn't exist yet)
        fs::path abs_p = fs::absolute(p);
        return abs_p.string();
    }
}


// This function is already portable thanks to boost::filesystem
std::string join_paths(std::initializer_list<std::string> paths) {
    fs::path result;
    for (const auto& path : paths) {
        if (!path.empty()) {
           if (result.empty()) {
               result = path;  
           } else {
               result /= path; 
           }
        }
    }
    return result.generic_string(); // Use generic_string for cross-platform forward slashes
}

bool is_string_in_vector(const std::vector<std::string>& vec, const std::string& target) {
    auto it = std::find(vec.begin(), vec.end(), target);
    return it != vec.end();
}

bool is_source_file(const fs::path& filePath) {
    std::string extension = filePath.extension().string();
    std::transform(extension.begin(), extension.end(), extension.begin(), ::tolower);
    return extension == ".c" || extension == ".s";
}

std::string replace_extension(const std::string& fileName, const std::string& newExtension) {
    fs::path p(fileName);
    return p.stem().string() + "." + newExtension;
}

// The rest of the static string getters remain the same.
// Just ensure the generated Makefile commands are compatible with the target system (Linux).
// The current commands like 'rm -rf', 'mkdir -p' are standard on Linux.
static std::string GET_COPYRIGHT_SUBSRC_MK() {
	return fmt::format(R"(
###############################################################################
# @file    subsrc.mk
# @author  castle (Automatic generated by makefile_gen.exe)
# @version {}
# @date    {}
# @brief   
# @attention
#
# THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
# WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
# TIME. AS A RESULT, MVSILICON SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
# INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
# FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
# CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
#
# <h2><center>&copy; COPYRIGHT 2021 MVSilicon </center></h2>
#/
###############################################################################


)",
ver, date);
}


static std::string GET_DEPS_MK() {
	return fmt::format(R"(
O_SRCS := 
C_SRCS := 
S_SRCS := 
S_UPPER_SRCS := 
OBJ_SRCS := 
ASM_SRCS := 
SAG_SRCS += \

OBJCOPY_OUTPUTS := 
OBJS := 
C_DEPS := 
GCOV_OUT := 
SYMBOL_OUTPUTS := 
READELF_OUTPUTS := 
GPROF_OUT := 
SIZE_OUTPUTS := 
EXECUTABLES := 
S_UPPER_DEPS := 

SUBDIRS := \
{} \

)",
objs_folder);
}


static std::string GET_OBJ_LIBS_MK() {
	return fmt::format(R"(
USER_OBJS :=
LIBS :=)"
);
}


static std::string GET_MAIN_MAKEFILE() {
	return fmt::format(R"(
###############################################################################
# @file    makefile
# @author  castle (Automatic generated by makefile_gen.exe)
# @version {}
# @date    {}
# @brief   
# @attention
#
# THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
# WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
# TIME. AS A RESULT, MVSILICON SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
# INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
# FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
# CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
#
# <h2><center>&copy; COPYRIGHT 2021 MVSilicon </center></h2>

###############################################################################
ifndef ANDESIGHT_ROOT
ANDESIGHT_ROOT=/cygdrive/C/Andestech/AndeSight300STD
endif

# On Linux, you might want to set a proper default path for the toolchain
ifndef CROSS_COMPILE
CROSS_COMPILE=nds32le-elf-
endif

ifndef SECONDARY_OUTPUT_PATH
SECONDARY_OUTPUT_PATH=output
endif

$(shell mkdir -p $(SECONDARY_OUTPUT_PATH))

-include ../makefile.init

RM := rm -rf

# All of the sources participating in the build are defined here
#-include sources.mk
-include subsrc.mk
#-include objects.mk

ifneq ($(MAKECMDGOALS),clean)
ifneq ($(strip $(C_DEPS)),)
-include $(C_DEPS)
endif
ifneq ($(strip $(S_UPPER_DEPS)),)
-include $(S_UPPER_DEPS)
endif
endif

-include ../makefile.defs

# Add inputs and outputs from these tool invocations to the build variables 
BUILD_ARTIFACT_FILE_BASE_NAME = {}

LINKER_OUTPUTS = {}.adx

GCOV_OUT += \
$(foreach subdir,$(SUBDIRS),$(wildcard $(subdir)/*.gcda) $(wildcard $(subdir)/*.gcno)) \

GPROF_OUT += \
../gmon.sum ../gmon.out \

SYMBOL_OUTPUTS += \
$(SECONDARY_OUTPUT_PATH)/symbol.txt \

READELF_OUTPUTS += \
$(SECONDARY_OUTPUT_PATH)/readelf.txt \

OBJDUMP_OUTPUTS += \
$(SECONDARY_OUTPUT_PATH)/objdump.txt \

OBJCOPY_OUTPUTS += \
$(SECONDARY_OUTPUT_PATH)/$(BUILD_ARTIFACT_FILE_BASE_NAME).bin \

SIZE_OUTPUTS += \
$(SECONDARY_OUTPUT_PATH)/.PHONY.size \

MAIN_CONFIG_FILES += \
{}

# All Target
all: pre-build 
	@echo "Starting build..."
	@START_TIME=$$(date +%s); \
	$(MAKE) main-build; \
	END_TIME=$$(date +%s); \
	DIFF=$$((END_TIME - START_TIME)); \
	echo "Total time taken: $$DIFF seconds"

# Main-build Target
main-build: {}.adx secondary-outputs

# Tool invocations
{}.adx: $(OBJS) $(USER_OBJS)
	@echo 'Building target: $@'
	@echo 'Invoking: Andes C Linker'
	$(CROSS_COMPILE)gcc {} {} -o "{}.adx" $(OBJS) $(USER_OBJS) $(LIBS)
	@echo 'Finished building target: $@'
	@echo ' '

$(foreach subdir,$(SUBDIRS),$(wildcard $(subdir)/*.gcda) $(wildcard $(subdir)/*.gcno)): {}.adx $(OBJS) $(USER_OBJS)
../gmon.sum ../gmon.out: {}.adx $(OBJS) $(USER_OBJS)

$(SECONDARY_OUTPUT_PATH)/symbol.txt: $(LINKER_OUTPUTS)
	@echo 'Invoking: NM (symbol listing)'
	$(CROSS_COMPILE)nm -n -l -C "{}.adx" > $(SECONDARY_OUTPUT_PATH)/symbol.txt
	@echo 'Finished building: $@'
	@echo ' '

$(SECONDARY_OUTPUT_PATH)/readelf.txt: $(LINKER_OUTPUTS)
	@echo 'Invoking: Readelf (ELF info listing)'
	$(CROSS_COMPILE)readelf -a "{}.adx" > $(SECONDARY_OUTPUT_PATH)/readelf.txt
	@echo 'Finished building: $@'
	@echo ' '

$(SECONDARY_OUTPUT_PATH)/$(BUILD_ARTIFACT_FILE_BASE_NAME).bin: $(LINKER_OUTPUTS)
	@echo 'Invoking: Objcopy (object content copy)'
	$(CROSS_COMPILE)objcopy -S -O binary "{}.adx" $(SECONDARY_OUTPUT_PATH)/$(BUILD_ARTIFACT_FILE_BASE_NAME).bin
	@echo 'Finished building: $@'
	@echo ' '

$(SECONDARY_OUTPUT_PATH)/.PHONY.size: $(LINKER_OUTPUTS)
	@echo 'Invoking: Size (section size listing)'
	$(CROSS_COMPILE)size  "{}.adx" | tee $(SECONDARY_OUTPUT_PATH)/.PHONY.size
	@echo 'Finished building: $@'
	@echo ' '

$(SECONDARY_OUTPUT_PATH)/objdump.txt: $(LINKER_OUTPUTS)
	@echo 'Invoking: Objdump (disassembly)'
	$(CROSS_COMPILE)objdump -x -d -C "{}.adx" > $(SECONDARY_OUTPUT_PATH)/objdump.txt
	@echo 'Finished building: $@'
	@echo ' '

# Other Targets
clean:
	-$(RM) $(OBJCOPY_OUTPUTS)$(OBJS)$(C_DEPS)$(GCOV_OUT)$(SYMBOL_OUTPUTS)$(OBJDUMP_OUTPUTS)$(READELF_OUTPUTS)$(GPROF_OUT)$(SIZE_OUTPUTS)$(EXECUTABLES)$(S_UPPER_DEPS) {}.adx
	-@echo ' '

pre-build:
	-{}
	-@echo ' '

config: $(MAIN_CONFIG_FILES)
	-{}
	-@echo ' '

secondary-outputs: $(SYMBOL_OUTPUTS) $(READELF_OUTPUTS) $(OBJDUMP_OUTPUTS) $(OBJCOPY_OUTPUTS) $(SIZE_OUTPUTS)

.PHONY: all clean dependents config
.SECONDARY: main-build pre-build
.NOTPARALLEL: pre-build

-include ../makefile.targets
)",ver, date, 
project_name, project_name, 
config_src_long_str, 
project_name,
project_name, libs_search_long_str, link_option_long_str, 
project_name,project_name,project_name, project_name, project_name, project_name, project_name, project_name, project_name, 
pre_build_script, config_tool_path_cmd
);
}

int main(int argc, char** argv) {

	/*Welcome information*/
	fs::path full_path = fs::current_path();
    fmt::print("MVsilicon Makefile Generator version {} for MVS SDK.\n", ver);
    fmt::print("current path: {}\n", full_path.string());

	/*check command line parameters*/
    try {
        po::options_description desc("Options");
        desc.add_options()
            ("help,h", "show help informations")
            ("inifile,i", po::value<std::string>(), "set ini input file")
            ("scandir,d", po::value<std::string>(), "set scan dir");

        po::variables_map vm;
        po::store(po::parse_command_line(argc, argv, desc), vm);
        po::notify(vm);

        if (vm.count("help")) {
            std::cout << desc << std::endl;
            return 0;
        }

        if (vm.count("inifile")) {
			ini_config_file = vm["inifile"].as<std::string>();
            // fmt::print("inifile set to {}.\n", ini_config_file);
        } else {
            // fmt::print("inifile not set.\n");
        }

        if (vm.count("scandir")) {
			scan_dir = vm["scandir"].as<std::string>();
            // fmt::print("Scan dir set to {}.\n", scan_dir);
        } else {
            // fmt::print("Scan dir not set.\n");
        }

    } catch(const po::error &ex) {
        fmt::print(stderr, "Error: {}\n", ex.what());
        return 1;
    }
    
    // If scan_dir is not provided, use the current directory.
    if(scan_dir.empty()){
        scan_dir = fs::current_path().string();
    }

	scan_dir = to_absolute(scan_dir);
	if (!fs::exists(scan_dir) || !fs::is_directory(scan_dir))
	{
		fmt::print("dir not existed! {}\n", scan_dir);
		return -1;
	}
	fmt::print("abs dir: {}\n", scan_dir);


	date = getCurrentTimestampString();

	/*parse the ini file*/
	IniParser data(ini_config_file);

	project_name = data.GetValue("brief_info","project_name");
	make_folder = data.GetValue("brief_info","make_folder");
	objs_folder = data.GetValue("brief_info","objs_folder");
	pre_build_script = data.GetValue("brief_info","pre_build_script");
	config_tool_path = data.GetValue("brief_info","config_tool_path");

	fmt::print("project name: {}\n", data.GetValue("brief_info", "project_name"));

    // Use boost::filesystem to create paths portably
    fs::path base_path(scan_dir);
    fs::path make_path = base_path / make_folder;
    fs::path objs_path = make_path / objs_folder;

    fs::create_directory(make_path);
    fs::create_directory(objs_path);

	/*process recursive dirs*/
	if (data.HasSection("recursive_dir_search"))
	{
		for (const auto& pair : data["recursive_dir_search"]) {
			recursive_req.push_back(pair.first);
		}
	}

	for (const auto& rec_dir : recursive_req)
	{
        fs::path target_dir = base_path / rec_dir;
		if (fs::exists(target_dir) && fs::is_directory(target_dir))
		{
			for (auto& entry : fs::recursive_directory_iterator(target_dir))
			{
				if(fs::is_directory(entry.path()))
				{
                    fs::path relative_path = fs::relative(entry.path(), base_path);
					recursive_search_all.push_back(relative_path.generic_string());
				}
			}
		}
	}

	if (data.HasSection("exclude_source"))
	{
		for (const auto& pair : data["exclude_source"]) {
			exclude_src_list.push_back(pair.first);
		}
	}

	if (data.HasSection("compile_option"))
	{
		for (const auto& pair : data["compile_option"]) {
			compile_option_list.push_back(pair.second);
		}
	}

    // --- PORTABILITY FIX ---
    // Use boost::filesystem to correctly join paths regardless of OS.
#ifdef _WIN32
    // Original Windows-specific code with hardcoded separator
    std::ofstream fomk(join_paths({scan_dir, make_folder}) + "\\subsrc.mk");
    fmt::print("Original code was: std::ofstream fomk(join_paths({{scan_dir, make_folder}}) + \"\\\\subsrc.mk\");\n");
#else
    // Correct, portable code for all platforms
    fs::path subsrc_mk_path = make_path / "subsrc.mk";
    std::ofstream fomk(subsrc_mk_path.string());
#endif
    
	fomk << GET_COPYRIGHT_SUBSRC_MK();
	fomk << GET_DEPS_MK();
	fomk << GET_OBJ_LIBS_MK();

	if (data.HasSection("link_libs"))
	{
		for (const auto& pair : data["link_libs"]) {
			fomk << " -l" << pair.first;
		}
	}

	fomk << std::endl;

	std::vector<std::string> source_folder_list;
	if (data.HasSection("source_folder"))
	{
		for (const auto& pair : data["source_folder"]) {
			source_folder_list.push_back(pair.first);
		}
	}
	for (const auto& rec_dir : recursive_search_all) {
		source_folder_list.push_back(rec_dir);
    }

	/*search all source files, save in src_main_list*/
	try {
		for (const auto& search_folder : source_folder_list) {
            fs::path current_dir = base_path / search_folder;
			if (!fs::exists(current_dir) || !fs::is_directory(current_dir)) continue;

			for(const auto& afile : fs::directory_iterator(current_dir))
			{
				std::string file_name_str = afile.path().filename().string();
				if(is_string_in_vector(exclude_src_list, file_name_str)) continue;

                // --- PORTABILITY FIX ---
                // Use generic_string() to get path with forward slashes for makefile
#ifdef _WIN32
                // Original code that manually replaces slashes
                std::string full_name_str = join_paths({current_dir.string(), file_name_str});
				std::replace(full_name_str.begin(), full_name_str.end(), '\\', '/');
#else
                // Better portable version
                std::string full_name_str = afile.path().generic_string();
#endif
				if(fs::is_regular_file(afile.path()) && is_source_file(file_name_str))
				{
					std::string o_filename = replace_extension(file_name_str, "o");
					std::string d_filename = replace_extension(file_name_str, "d");
					std::vector<std::string> item = {file_name_str, o_filename, d_filename, full_name_str, full_name_str};
					src_main_list.push_back(item);
				}
			}
		}
	} catch (const fs::filesystem_error& ex) {
            std::cerr << "filesystem error: " << ex.what() << std::endl;
    }


	source_folder_list.clear();
	if (data.HasSection("header_folder"))
	{
		for (const auto& pair : data["header_folder"]) {
			source_folder_list.push_back(pair.first);
		}
	}
	for (const auto& rec_dir : recursive_search_all) {
		source_folder_list.push_back(rec_dir);
    }

	for (const auto& search_folder : source_folder_list) {
        // --- PORTABILITY FIX ---
#ifdef _WIN32
        // Original code with manual slash replacement
		std::string full_path = join_paths({scan_dir, search_folder});
		std::replace(full_path.begin(), full_path.end(), '\\', '/');
		std::vector<std::string> item = {full_path, full_path};
#else
        // Correct portable version using boost
        fs::path full_path = base_path / search_folder;
		std::vector<std::string> item = {full_path.string(), full_path.string()};
#endif
		inc_full_path_list.push_back(item);
    }

	//C_SRCS +=
	fomk << "\nC_SRCS += \\\n";
	for (const auto& item : src_main_list) {
		fomk << item[3] << "\\\n";
    }

	//#OBJS += 
	fomk << "\nOBJS += \\\n";
	for (const auto& item : src_main_list) {
		fomk << "./" << objs_folder << "/" << item[1] << "\\\n";
    }

	//#C_DEPS += 
	fomk << "\nC_DEPS += \\\n";
	for (const auto& item : src_main_list) {
		fomk << "./" << objs_folder << "/" << item[2] << "\\\n";
    }


	std::string defined_symbols_long_str;
	if (data.HasSection("defined_symbols"))
	{
		for (const auto& pair : data["defined_symbols"]) {
			defined_symbols_long_str += "-D " + pair.second + " ";
		}
	}

	if (data.HasSection("config_src_file"))
	{
		for (const auto& pair : data["config_src_file"]) {
			config_src_long_str += objs_folder + "/" + pair.first + ".o" + " \\\n";
		}
	}


	//make rules
	for (const auto& item : src_main_list) {
		fomk << "\n" << objs_folder + "/" + item[1] + ": " + item[3] + "\n";
        fomk << "\t" << "@echo 'Building file: $<'" << "\n";
        fomk << "\t" << "@echo 'Invoking: Andes C Compiler'" << "\n";
        fomk << "\t" << "$(CROSS_COMPILE)gcc " << defined_symbols_long_str;

		for (const auto& incs : inc_full_path_list) {
			fomk << "-I\"" << incs[1] << "\" ";
		}

		for (const auto& compile_opt : compile_option_list) {
			fomk << compile_opt << " ";
		}

		fomk << "\n";
        fomk << "\t" << "@echo 'Finished building: $<'" << "\n";
        fomk << "\t" << "@echo ' '" << "\n";
    }

	fomk.close();

/*********************************************************************************/
	if (data.HasSection("link_libs_search"))
	{
		for (const auto& pair : data["link_libs_search"]) {
            fs::path full_path = base_path / pair.first;
			libs_search_long_str += "-L\"" + full_path.generic_string() + "\" ";
			
		}
	}
	for (const auto& rec_dir : recursive_search_all) {
        fs::path full_path = base_path / rec_dir;
		libs_search_long_str += "-L\"" + full_path.generic_string() + "\" ";
	}

	if (data.HasSection("link_option"))
	{
		for (const auto& pair : data["link_option"]) {
			link_option_long_str += pair.second + " ";
		}
	}

    // --- PORTABILITY FIX ---
#ifdef _WIN32
    // Original Windows-specific code
    std::ofstream makefile_file(join_paths({scan_dir, make_folder}) + "\\makefile");
    fmt::print("Original code was: std::ofstream makefile_file(join_paths({{scan_dir, make_folder}}) + \"\\\\makefile\");\n");
#else
    // Correct, portable code for all platforms
    fs::path makefile_path = make_path / "makefile";
    std::ofstream makefile_file(makefile_path.string());
#endif
    
	makefile_file << GET_MAIN_MAKEFILE();
	makefile_file.close();

    fmt::print("Makefile generation complete.\n");

    return 0;
}